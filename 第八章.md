# 《代码大全2》第八章 “防御式编程” 读书笔记

## 8.1 保护程序免遭非法输入数据的破坏

对已形成产品的软件而言,仅仅“垃圾进,垃圾出”还不够。不管进来什么,好的程序都不会生成垃圾,而是做到“垃圾进,什么都不出”、“进来垃圾,出去是出错提示”或“不许垃圾进来”。
通常有三种方法来处理进来垃圾的情况： 
1. 检查所有来源于外部的数据的值
2. 检查子程序所有输入参数的值
3. 决定如何处理错误的输入数据
   
## 8.2 断言

* 用错误处理代码来处理预期会发生的状况,用断言来处理绝不应该发生的状况：  
* 断言是用来检查永远不该发生的情况
* 断言是用于检查代码中的bug
* 可以把断言看做是可执行的注解
* 用断言来注解并验证前条件和后条件前条件（相当于与其余部分都形成了一份契约）
* 对于高健壮性的代码,应该先使用断言再处理错误（两种措施同时使用）

``` 读后感
个人理解：断言相当于能够运行的注释，是代码之间的一份“契约”，当其他开发者的修改破坏了“契约”，断言能够主动指出修改存在问题。
但是目前使用Release模式开发的产品没有办法使用这一便利的工具。
```

## 8.3 错误处理技术

* 断言可以用于处理代码中不应发生的错误，错误处理技术处理那些预料中可能要发生的错误
* 可以采用的措施：
    1. 返回中立值
    2. 换用下一个正确数据
    3. 返回与前次相同的值
    4. 换用最接近的有效值
    5. 在日志文件中记录警告信息
    6. 返回一个错误码
    7. 调用错误处理子程序或对象
    8. 显示出错信息或者关闭程序
    9. 或把这些技术结合起来使用
* 权衡健壮性与正确性：有的场景宁可返回，也不能返回错误的数值，此时需要牺牲健壮性来保证正确性；相反有的时候需要有返回值来保证软件的正常运行不崩溃，牺牲正确性来保证健壮性。

``` 读后感
难点在与根据所处的场景选择合适的处理措施，不合适的处理措施将会成为非常隐蔽的bug
```

## 8.4 异常

异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段，如一个子程序遇到了预料之外的情况,不知道该如何处理的情况,此时需要抛出异常。审慎明智地使用异常,它可以降低复杂度；而草率粗心地使用时,只会让代码变得几乎无法理解。

* 用异常通知程序的其他部分,发生了不可忽略的错误（能够避免错误扩散）
* 只在真正例外的情况下才抛出异常（否则会增加复杂性、弱化封装性）
* 不能用异常来推卸责任（如果某种的错误情况可以在局部处理,那就应该在局部处理掉它。）
* 避免在构造函数和析构函数中抛出异常,除非你在同一地方把它们捕获（构造未完成会导致析构无法调用）
* 在恰当的抽象层次抛出异常
* 在异常消息中加入关于导致异常发生的全部信息
* 避免使用空的 catch语句（至少要记录到日志里）
* 了解所用函数库可能抛出的异常（未捕获，可能会崩溃）
* 考虑创建一个集中的异常报告机制
* 把项目中对异常的使用标准化
* 考虑异常的替换方案

## 8.5 隔离程序,使之包容由错误造成的损害

通过对穿越安全区域边界的数据进行合法性校验,并进行清理，实现隔离

## 8.6 辅助调试的代码

* 在调试时可以适当的牺牲一些运行速度和资源，来换取更顺畅的开发体验
* 通过辅助代码，进攻性的暴露问题，在开发阶段处理
* 计划移除调试辅助代码（发布前确保移除）
  
## 8.7 确定在产品代码中该保留多少防御式代码

* 保留那些检查重要错误的代码
* 去掉检查细微错误的代码
* 去掉可以导致程序硬性崩溃的代码
* 保留可以让程序稳妥地崩溃的代码
* 为你的技术支持人员记录错误信息
* 确认留在代码中的错误消息是友好的
  
## 8.8 对防御式编程采取防御的姿态

过度的防御式编程也会引起问题。

``` 读后感
读后感：商业软件需要充分考虑健壮性，只是实现了主流程，当用户输入异常的数据的时候就会“garbage in, garbage out”。
软件运行时出现的问题相较于主流场景比较不常见，往往难以完全预料，通过辅助代码可以帮助开发者在编码期间提前发现问题，发现错误。
断言可以用于处理代码中不应发生的错误
错误处理技术处理预料到的，能够想到处理方式的
异常用于抛出不知如何处理的错误
```