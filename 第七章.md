# 《代码大全2》第七章 “高质量的子程序” 读书笔记

子程序也算得上是计算机科学中一项最为重大的发明了。
子程序的使用使得程序变得更加易读,更易于理解,比任何编程语言的任何功能特性都更容易。

## 7.1创建子程序的正当理由

* 降低复杂度:可以通过创建子程序来隐藏一些信息,这样你就不必再去考虑这些信息了。缩小代码规模、改善可维护性、提高正确性
* 引入中间、易懂的抽象:把一段代码放入一个命名恰当的子程序内,是说明这段代码用意最好的方法之一。
* 避免代码重复
* 支持子类化
* 隐藏顺序
* 隐藏指针操作
* 提高可移植性
* 简化复杂的逻辑判断
* 改善性能
除此之外,创建类的很多理由也是创建子程序的理由:
* 隔离复杂度
* 隐藏实现细节
* 限制变化所带来的影响
* 隐藏全局数据
* 形成中央控制点
* 促成可重用的代码
* 达到特定的重构目的

``` 读后感
通过函数可以减少重复的代码，好的函数命名能够大幅提高代码的可读性。
在工作中经常见到有的函数中只有几行甚至一行代码，代码评审时会讨论这么短的函数是否有必要封成函数。通过书中的介绍明白了这样可以提高代码可读性，并且在这个短函数被调用次数比较多的情况下，可以实现一处修改，全局统一变化的好处，从而降低维护过程的复杂度。
```

## 7.2 在子程序层上设计

* 内聚性是指子程序中各种操作之间联系的紧密程度
* 功能的内聚性(functional cohesion)是最强也是最好的一种内聚性,也就是说让一个子程序仅执行一项操作。
* 不够理想的内聚性：
    1. 顺序上的内聚性
    2. 通信上的内聚性
    3. 临时的内聚性
* 不可取的内聚性：
    1. 过程上的内聚性
    2. 逻辑上的内聚性
    3. 巧合的内聚性

``` 读后感
在读代码中见到过一些函数名称中有“and”，对阅读代码造成了非常大的困难，这类函数具有不可取的“过程上的内聚性”，因为外界的调用往往是两个过程一起顺序调用，所以直接写在了一起。将and前后做的两件事情拆开写到两个函数中可以以很好的实现“功能的内聚性”，让一个函数只完成一个功能，降低理解的门槛。
```

## 7.3 好的子程序名字

* 描述子程序所做的所有事情
* 避免使用无意义的、模糊或表述不清的动词有些动词  
    反例：Handlecalculation()、 PerformServices()、
 OutputUser()、 ProcessInput()和 DealWithoutput()
 * 不要仅通过数字来形成不同的子程序名字  
    反例：OutputUser、 OutputUser1和 OutputUser22
* 函数命名时要对返回值有所描述（对象名称清晰时可以省略宾语）
* 给过程起名时使用语气强烈的动词加宾语的形式
* 准确使用对仗词，eg：  
    begin/end  
    insert/delete  
    show/hide
    create/destroy  
    lock/unlock  
    source/target  
    first/last  
    min/max  
    start/stop  
    get/put  
    next/previous  
    up/down  
    get/set  
    old/new  
* 为常用操作确立命名规则

``` 读后感
好的命名能够清晰地表述函数的作用，从而封装复杂度，阅读代码的人通过名称就能够明白用意， 而无需关心内部的实现。
起名字时确实容易偷懒，使用Handle、Process、Deal导致维护的人对函数的作用理解不清，应该尽量避免。
```

## 7.4 子程序可以写多长

在超过200行后,你迟早会在可读性方面遇到问题

## 7.5 如何使用子程序参数

* 按照输入修改-输出的顺序排列参数（暗含了子程序的内部操作顺序）
* 考虑自己创建IN和OUT关键词（利用宏，说明作用，编译器不强制）
* 如果几个子程序都用了类似的一些参数,应该让这些参数的排列顺序保持一致
* 使用所有的参数
* 把状态或出错变量放在最后（附属于程序的主要功能）
* 不要把子程序的参数用做工作变量（不要修改输入变量，可通过const限制）
* 在接口中对参数的假定加以说明
* 把子程序的参数个数限制在大约7个以内
* 考虑对参数采用某种表示输入、修改、输出的命名规则
* 为子程序传递用以维持其接口抽象的变量或对象

``` 读后感
参数的设置能够帮助读者理解接口的功能和用意，在代码中见到过有非常多参数的接口，在没有必要理由的情况下尽量避免，可以将参数聚类为一个对象传入。
```
## 7.6 使用函数时要特别考虑的问题

* 除非万不得已，谨慎使用宏， 替代技术：  
    const可以用于定义常量
    inline可以用于定义可被编译为内嵌的代码(n1ne《inInecode)的函数
    template可以用于以类型安全的方式定义各种标准操作,如min、max等
    enum可以用于定义枚举类型
    typedef可以用于定义简单的类型替换