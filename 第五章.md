# 《代码大全2》第五章 “软件构建中的设计” 读书笔记

## 5.1设计中的挑战

* 设计是一个“险恶(wicked)的问题”，即只有通过解决或部分解决才能被明确的问题
* 设计是个了无章法的过程：需要不断试错，设计很难界定完成的节点
* 设计能得出清爽的成果
* 设计就是确定取舍和调整顺序的过程
  
``` 读后感
在设计期的进行快速试错能够避免在编码期花费时间在不合理的方案上，从而从整体上节约时间。  
在以往的工作中，总是把做出完美的设计作为设计期的目标，但是每次的设计结果都不是很理想。
通过这一节的阅读，设计确实很难做到完美，它非常依赖经验，过程中需要试错、讨论、验证、评估、取舍、迭代改进，很难回答什么时候算是设计完成，具有不确定性，但是好的设计能够得出清爽的成果。
```

## 5.2关键的设计概念

### 软件的首要技术使命：管理复杂度

* 软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。
* 复杂度分为偶然复杂度和本质复杂度，本质复杂度不可减少，源自于问题本身，偶然复杂度源自于事务附属的、非必要的或偶然出现的性质。
* 管理复杂度：把任何人在同一时间需要处理的本质(essential)复杂度的量减到最少，不要让偶然性（accidental)的复杂度无谓地快速增长。
* 设计技术的目标都是把复杂问题分解成简单的部分，精心设计的对象关系使关注点相互分离。

``` 读后感
本质复杂度源自于问题本身的复杂度，不可以减少，好的设计会将复杂的问题分解，并保证需要程序员同一时间关注的本质复杂度最少，降低理解成本，确保有限注意力能够用于处理想要处理的问题。
好的设计会应该限制偶然复杂度的增长，当没有人知道修改一处代码会对其他代码产生什么样的影响的时候，维护就会变得异常艰难。
```

### 理想的设计特征

* 理想的设计特征：最小复杂度、易于维护、松散耦合、可扩展性、可复用性、高扇入、底扇出、可移植性、精简性、层次性、标准技术
  
``` 读后感
避免做出“聪明”的设计方案，这类方案往往难以理解，难以维护，应该做成简单且易于理解的。
好的设计应该尽可能多的使用标准的技术，让尽可能多的人更容易理解，降低学习成本和理解维护成本，也能够降低偶然复杂度。
```

### 设计的层次

* 设计的层次：软件系统、分解为子系统和包、分解包中的类、分解为类中的数据和子程序、子程序内部
* 子系统层次的通信设计应该是无环图。

``` 读后感
在子系统层次要限制系统之间的通信和依赖，从而降低系统之间的耦合，降低维护时的理解成本，测试成本。降低偶然复杂度。
```

## 5.3设计构造块：启发式方法

* 找出现实世界中的对象：
    1. 辨识对象及其属性(方法（method)和数据(data))。
    2. 确定可以对各个对象进行的操作。
    3. 确定各个对象能对其他对象进行的操作。
    4. 确定对象的哪些部分对其他对象可见一—哪些部分可以是公用(public)的，
    5. 哪些部分应该是私用（private)的。
    6. 定义每个对象的公开接口(public interface)。
* 形成一致的抽象：抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能在不同的层次处理不同的细节。
* 封装实现细节：封装是说，不只是让你能用简化的视图来看复杂的概念，同时还不能让你看到复杂概念的任何细节。你能看得到的就是你能全部得到的
* 当继承能简化设计时就继承：继承的好处在于他能很好地辅佐抽象的概念，是面向对象编程中最强大的工具之一
* 隐匿秘密：信息隐藏是结构化程序设计与面向对象设计的基础之一：
    1. 隐藏复杂度
    2. 隐藏变化源，将其影响限制在局部范围内。
* 找出容易变化的区域：找出看起来容易变化的项目、把容易变化的项目分离出来、把看起来容易变化的项目隔离开来
* 不要使用布尔量作为状态变量，改用枚举类型，因为给状态变量增加一个状态是很常见的。
* 保持松散的耦合
* 查阅常用的设计模式：设计模式精练了众多现成的解决方案
    1. 设计模式通过现成的抽象来减少复杂度
    2. 设计模式通过把常见解决方案的细节予以制度化来减少出错
    3. 设计模式通过通过提供多种设计方案而带来启发性的价值
    4. 设计模式通过把设计对话提升到一个更高的层次上来简化交流
* 常见设计模式

|模式|描述|
|----------|----------|
|Abstract Factory（抽象工厂)    |通过指定对象组的种类而非单个对象的类型来支持创建|
|Adapter(适配器）               |把一个类的接口转变成为另一个接口|
|Bridge(桥接)                   |把接口和实现分离开来，使它们可以独立地变化|
|Composite(组合)                |创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象|
|Decrorator(装饰器)             |给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类)|
|Facade(外观）                  |为没有提供一致接口的代码提供一个一致的接口|
|Factory Method                 |做特定基类的派生类的实例化时，除了在FactoryMethod内部之外均无须了解各派生对象的具体类型|
|Iterator(迭代器)               |提供一个服务对象来顺序地访问一组元素中的各个元素|
|Observer(观察者）              |使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象|
|Singleton(单件)                |为有且仅有一个实例的类提供一种全局访问功能|
|Strategy(策略）                |定义一组算法或者行为，使得它们可以动态地相互替换|
|Template Method（模板方法)     |定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类)|

``` 读后感
设计模式能够提供现成的解决方案，帮助更快完成易于理解的设计方案，难点在于找出最合适的模式，不应该为了使用设计模式而使用，这就要求充分理解每一种设计模式，知道其所适用于解决的问题。
```

## 5.4设计实践

介绍了迭代、分而治之、自上而下、自下而上、建立实验性原型等方法论
  
## 5.5对流行的设计方法的评论

略
