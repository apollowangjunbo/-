# 《代码大全2》第二十四章 “重构” 读书笔记

在整个项目生命周期中代码都会不断地演化

## 24.1软件演化的类型
* 程序构建过程中的演化：系统处于高度动态阶段,出现错误的代价较小
* 维护过程中的修改  
软件演化是无法避免且具有重要意义的现象，演化一开始就充满危险,但同时也是使你的软件开发接近完美的天赐良机，软件演化的基本准则就是,演化应当提升程序的内在质量。
## 24.2重构简介
在不改变软件外部行为的前提下,对其内部结构进行改变,使之更容易理解
并便于修改
### 重构的理由
1. 代码重复
``` 感想
感想：
      “复制粘贴即设计之谬”，修改代码时不得不记得同时修改多处，后人维护的时候一旦忘记就会引入bug，
      之前做过一个小需求，修改软件显示的两个字，原本只需要改一个字符串，
      结果全局好多处都在通过这个字符串做条件判断，
      这两个字在软件中应用场景很多，又不能通过搜索替换的凡是批量处理。
      实际上我们有很多方式能够避免重复，子程序、继承、模板 甚至动态库静态库。
```  
2. 子程序太长
``` 感想
感想：模块化，封成更短的，功能单一的子程序，之前写过一个600行的初始化UI的子程序，自己都不想看
```  
3. 循环太长或者嵌套太深（循环内部的复杂代码常常具备转换为子程序的潜质）
4. 类的内聚性太差（某个类大包大揽了许多彼此无关的任务）
5. 类的接口的抽象层次不一致
6. 参数表中参数太多（参数是否应该封为结构体）
7. 类的内部修改往往局限于某个部分（类是否能够拆分为多个类）
8. 需要对多个类进行并行修改（类是否可以重新组织）
9. 对继承体系的并行修改
10. 需要对多个case语句进行并行修改（采用继承也许更合适）
11. 相关的数据项只是被放在一起,没有组织到类中
12. 成员函数更多地使用了其他类的功能,而非自身类的（这个函数也许不应该属于这个类）
13. 过多使用基本数据类型
14. 一个类不做什么事（重构之后没清理，后面的程序员会困惑）
15. 一连串传递流浪数据的子程序
16. 中间人对象什么也不干
17. 某个类同其他类关系过于密切
18. 子程序的命名太差
19. 数据成员被设置为公用
20. 派生类仅仅使用了基类的一小部分成员函数（是否应该把派生类改为基类的数据成员）
21. 用注释来掩饰拙劣的代码
22. 使用了全局变量
23. 在子程序调用前使用设置代码,调用后使用收尾代码（接口的抽象不合理）
24. 程序包含的某些代码似乎在将来某个时候才会被用到（不应该超前设计，尽可能将满足当前需求的代码清晰直白地表现出来,使未来的程序员理解这些代码到底完成了什么功能,没有完成什么功能）

``` 感想
感想：编码很难在一开始就想清楚所有的事情，随着编码的进行，开发者对事情逻辑的理解会逐渐深入；
或者完成编码后的一段时间回头看可能会有新的理解；
或者一段程序经过太多补丁处理，已经非常难以理解了，这些都是可以是重构的理由，
重构的目的一定是要提升代码的质量。
```  
## 24.3特定的重构
### 数据级的重构
1. 用具名常量来代替神秘数值
2. 用更明确或更具信息量的名字来重命名变量
3. 将表达式内联化
4. 用函数来代替表达式
5. 引入中间变量
6. 将多用途变量转换为多个单一用途变量
7. 使用局部变量实现局部用途而不是使用参数
8. 将基础数据类型转化为类
9. 将一组类型码转化为类或是枚举类型
10. 将一组类型码转化为含派生类的类
11. 将数组转化为对象
12. 封装群集
13. 用数据类替代传统记录
### 语句级的重构
1. 分解布尔表达式
2. 将复杂的的布尔表达式转换为命名精确的布尔函数
3. 将条件语句中不同部分中的重复代码合并
4. 使用 break或 return而不是循环控制变量
5. 在嵌套的if-thenlse语句中一旦知道结果就立刻退出,而不是仅仅赋一个返回值
6. 用多态来代替条件语句(尤其是重复的case语句)
7. 创建并使用空对象代替对空值的检测
### 子程序级的重构
1. 提取子程序
2. 将子程序代码内联化
3. 将冗长的子程序转化为类
4. 用简单的算法替代复杂算法
5. 增加参数
6. 减少参数
7. 将查询操作同修改操作区分开来
8. 合并功能相似的子程序,并用参数来区分他们
9. 通过传递不同的参数使子程序体现不同的功能
10. 传递整个对象而非特定成员
11. 传递特定成员而非整个对象
12. 封装向下转型操作
### 类实现的重构
1. 将值对象改为引用对象
2. 将引用对象改为值对象
3. 用数据初始化来代替虚函数
4. 改变成员函数或数据的位置
5. 将特定代码提出生成派生类
6. 将相似的代码合并起来放到基类中
### 类接口的重构
1. 将某成员子程序放到另一个类中
2. 将一个类转化成两个
3. 删除某个类
4. 隐藏委托关系
5. 去掉中间人
6. 用委托代替继承
7. 用继承代替委托
8. 引入外部子程序
9. 引入扩展类
10. 封装暴露在外的成员变量
11. 对不能修改的成员去掉set()函数
12. 隐藏在类的外部不会使用的成员函数
13. 封装不会用到的成员函数
14. 如果基类和派生类的代码实现相似,将二者合并
### 系统级的重构
1. 为无法控制的数据创建明确的索引源
2. 将单向类联系改为双向类联系
3. 将双向的类联系改为单向类联系
4. 使用工厂函数而非简单的构造函数
5. 用异常代替错误代码,或者反其道而行之
## 24.4安全的重构
* 重构的步伐请小些
* 同一时间只做一项重构
* 把要做的事情一条条列出来
* 利用编译器警告信息
* 重新测试
* 增加测试用例
* 检查对代码的修改
* 根据重构风险级别来调整重构方法
* 避免用重构代替重写
## 24.5重构策略
``` 感想
感想：
真实的世界是复杂的，我们的代码经常需要处理复杂的业务规则而混乱，
我们通过接口将复杂的因素处理成理想的情况，在通过清晰的逻辑去处理理想的情况，
在重构的过程中尽可能扩大逻辑清晰的理想情况的代码的边界，
减少对接复杂业务逻辑的混乱的代码。
```

``` 读后感
读后感：
      经过最近的任务，更深刻的理解了重构的代价，底层平台的重构，中台需要适配，产品有也需要适配，如果产品已经发版，还需要考虑升级，可能一个非常小的接口改动，都需要（配置产品环境，适配代码，打版，测试）*n的工作量。
      但是如果一个平台因为这些负担停止了代码的演化则无法持续交付价值，所以需要在不被负担拖垮的前提下重构，开发阶段重构的成本是最低的，所以需要尽早发现问题。
```  
