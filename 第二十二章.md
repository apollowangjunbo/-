# 《代码大全2》第二十二章 “开发者测试” 读书笔记

测试是最常见的改善质量的活动

* 单元测试(Unit testing)
* 组件测试( Component testing)
* 集成测试(Integration testing)
* 回归测试(Regression testing)
* 系统测试(System testing)
  测试也分为黑盒测试和白盒测试
  
## 22.1开发者测试在软件质量中的角色

* 对于任何软件质量规划来说,测试都是一个重要的组成部分，每个独立的测试步骤通常只能够找到现有错误的50%不到
* 测试的目标是找出错误，与其他开发活动的目标背道而驰
* 测试永远不可能彻底证明程序中没有错误
* 测试本身并不能改善软件的质量
* 测试时要求你假设会在代码里面找到错误（自我实现）
* 开发者测试应该占整个项目时间的8%~25%
  
怎样利用开发者测试的结果？

1. 评估正在开发的产品的可靠性
2. 用于指导对软件的修正
3. 帮助于你归纳出程序中最常见错误的类型，帮助去选择适当的培训课程、指引今后的技术复查活动,设计未来的测试用例。
   
## 构建中测试

白盒测试的好处：除了观察它的输入输出,还要察看内部的源代码。如果知道盒子里面的情况,可以更彻底地测试这个类
黑盒测试的好处：能测出开发过程中的盲点

* 独立运行测试相较于继承后的测试能够更简单的发现问题

``` 感想
感想：
      1. 有的时候开发人员与测是人员沟通起来会觉得测试的场景难以想象，实际上这就是黑盒测试带来的好处，能够找出开发过程中的盲点
      2. 子程序、类甚至是子模块在集成之前的测试通常会更加容易的发现问题，在集成之前，这部分代码 不受外部条件的影响，条件相对简单，更容易观察。另一方面没有连接界面之前测试用例的运行效率（接口测试）会高很多（相较于Ui自动化）。对于开发者而言，独立运行的部分编译和调试的速度都会快很多，能够快速试错，更容易的修正一个问题。但是独立运行需要剥离开外部的环境依赖，需要从设计时就考虑清楚。
```  

## 22.2开发者测试的推荐方法

1. 对每一项相关的需求进行测试,以确保需求都已经被实现
2. 对每一个相关的设计关注点进行测试,以确保设计已经被实现
3. 用基础测试( basis testing)来扩充针对需求和设计的详细测试用例
4. 增加数据流测试(data--flow test),然后补充其他所需的测试用例
5. 使用一个检查表,其中记录着你在本项目迄今为止所犯的,以及在过去的项目中所犯的错误类型  

在设计产品的时候设计测试用例,这样可以帮助避免在需求和设计中产生错
误,修正这些错误的代价往往比修正编码错误更昂贵越早修复这些缺陷,成本
就越低,因此,要尽可能早地对测试进行规划并找出缺陷。

### 测试先行还是测试后行（答案：测试先行）

* 首先写测试用例可以将从引入缺陷到发现并排除缺陷之间的时间缩减至最短
* 在开始写代码之前先写测试用例,并不比之后再写要多花功夫,只是调整了一下测试用例编写活动的工作顺序而已
* 假如你首先编写测试用例,那么你将可以更早发现缺陷,同时也更容易修正它们
* 首先编写测试用例,将迫使你在开始写代码之前至少思考一下需求和设计
* 先编写测试用例,能更早地把需求上的问题暴露出来

### 开发者测试的局限性

* 开发者测试倾向于“干净测试”，开发人员往往去做一些检验代码能否工作的测试(干净测试, clean tests),而不是做所有可能让代码失效的测试(肮脏测试,dirty tests)，肮脏应该更多
* 开发者测试对覆盖率有过于乐观的估计
* 开发者测试往往会忽略一些更复杂的测试覆盖率类型（所有分支覆盖）
开发者测试是有价值的,但对于提供足够的质量保证而言,仅仅进行开发者测试是不够的。我们需要补充其他的实践,包括独立测试(independent testing)技术以及协同构建collaborative construction)技术。

## 22.3测试技巧锦囊

通过测试来证明程序的正确性是不可能的呢

### 不完整的测试

需要集中注意力挑选出那些能告诉你不同答案的测试用例,而不选出一堆总是告诉你相同答案的测试用例。

### 结构化的基础测试

你需要去测试程序中的每一条语句至少一次，如果语句是一个逻辑语句，例如if语句或者 while语句,那么你就需要根据if者中表达式的复杂程度
来修改测试,以确保这个语句完全经过了测试，要确保你已经覆盖了所有的基础情况，这种测试能够向你保证所有的代码都得到执行但它并不能说明数据的变化情况。

### 数据流测试
数据使用的出错几率至少不亚于控制流，数据的状态应该按照“已定义”->“已使用”->“已销毁”的顺序变化，重复的定义和销毁、错乱的顺序都会引起bug

### 等价类划分
一个好的测试用例应该覆盖可输入数据中的很大一部分，如果两个用例能揭示的错误完全相同,那么只要一个就够了。

### 猜测错误
在猜测程序会在哪里出错使用软件隐的基础之上建立测试用例，基于直觉或者过去的经

### 边界值分析
可以发现分析off-by-one错误
### 复合边界值
当边界条件涉及到互相关联的多个变量的时，例如,两个变量相乘,它们的值都是大的正数
### 几类坏数据
* 数据太少(没有数据)
* 太多的数据
* 错误的数据情况(无效数据)
* 长度错误的数据
* 未初始化的数据

eg:薪水是负数、人数是负数

### 几类好数据

测试用例需要测试正常的数据是否能够正常工作，包括：
* 正常的情形大路正中间,所期望的值
* 最小的正常局面
* 最大的正常局面
* 与旧数据的兼容性

### 采用容易手工检查的测试用例

手工计算过程犯错的几率跟你在程序中发现错误的几率差不多，会增加测试的难度，选择容易手动计算的情况，也能帮助发现同样的错误

## 22.4典型错误

### 哪些类包含最多的错误

* 80%的错误存在于项目20%的类或者子程序当中
* 50%的错误被发现存在于项目5%的类当中
* 项目中20%的子程序占用了80%的开发成本
* 提高质量就能缩短开发周期,同时降低开发成本（避免卷入到那些烦人的子程序中,序,就是那些极那么你就可以省下近80%的成本从而节约一大段开发时间）

### 错误的分类

* 大多数错误的影响范围是相当有限的（85%的错误可以在修改不超过一个子程序的范围内得以修正）
* 许多错误发生在构建的范畴之外（缺乏应用领域知识,频繁变动且相互矛盾的需求,以及沟通和协调的失效）
* 大多数的构建期错误是编程人员的失误造成的（程序员造成的占95%，系统2%，其他软件2%，硬件1%）
* 笔误(拼写错误)是一个常见的问题根源（占36%）
* 错误理解设计（占16%-19%）
* 大多数错误都很容易修正（大约85%的错误可以在几个小时的时间内修正）

### 不完善的构建过程引发错误所占的比例
* 在小型项目里面, 75%的错误由编码造成，10%的错误源自需求,以及15%源自设计
* 无论项目规模如何,构建缺陷至少占了总缺陷的35%

### 你期望能发现多少错误
软件质量的普遍原则:开发高质量的软件,比开发低质量软件然后修正的成本要低廉

### 测试本身的错误
开发人员在编写测试用例，在没有经过仔细地设计和构建的前提下，测试用例可能包含同被测代码同样多,甚至是更多的错误，应对建议：
* 谨慎的开发测试用例并检查
* 开发软件的时候就要计划好测试用例
* 保留你的测试用例
* 将单元测试纳入测试框架

## 22.5测试支持工具

### 为测试各个类构造脚手架
在软件中搭建脚手架只有一个目的,那就是更方便地测试代码。
脚手架可以实现：
* 立刻返回控制权,不做任何动作
* 检查传给它的数据;
* 输出诊断信息,可能是显示所传入的参数,或者是将信息记录到日志文件中;
* 返回用户交互输入的值;
* 不管输入是什么都返回一个标准的响应;
* 消耗原本分配给真实对象或者真实子程序的时钟周期
* 以某种慢速、臃肿、简单或粗略的方式实现真实对象或者子程序的功能。

另一种脚手架类型,是调用待测试的真实函数的伪造函数。这种脚手架称为
“驱动函数”,有时也称为“测试夹具”。这种脚手架可以:
* 用固定的一组输入调用对象;
* 提示用户输入,然后根据输入去调用对象;
* 从命令行取得参数(如果操作系统支持)去调用对象
* 从文件中读入参数,并据此调用对象;
* 用一集预先定义的输入数据去多次调用有关的对象。

``` 感想
感想：
      目前在做的造价云适配任务里面就有一个前人搭好的脚手架GMPCloudServiceMoc，能够模拟造价云的返回结果，起作用是：不管输入是什么都返回一个标准的响应，使得测试过程变得更加便利
```  
### Diff Tools
一个能自动对比实际输出与期望输出的工具，便于进行回归测试（这个在重构的时候应该很有用，保证重构后的程序关键输出不变）
### 测试数据生成器
作者在开发加密解密程序的时候使用了这个技术，覆盖到了意想不到的场景，而且可以不消耗人力持续测试
### 覆盖率监视器
用来检测现有测试用例是否能够彻底地对代码进行测试，那些没有测量代码覆盖率的测试,通常只测试到了大约50%到60%的代码
### 数据记录器/日志记录器
略
### 符号调试器
完全按照计算机的方式来演绎代码的执行（这个不应该算是下一章调试的内容么）

### 系统干扰器
发现忘记初始化的问题
* 内存填充
* 内存抖动
* 选择性内存失败
* 内存访问检查
  
### 错误数据库
指的是目前在使用的jira

## 22.6改善测试过程
### 有计划的测试

### 重新测试(回归测试)

### 自动化测试
* 自动化测试发生错误的几率比手动测试要小。
* 一旦你把一个测试自动化了,那么你只需稍下功夫,就很容易在项目的剩余部分继续实施自动化。
* 如果测试是自动进行的,那么就可以频繁地运行
* 自动化测试可以提高问题刚产生就被发现的可能性
* 为大规模代码修改提供了一张安全网
  
## 22.7保留测试记录

指的是目前在使用的jira，通过记录数据更宏观的观察项目的趋势。

``` 读后感
读后感：
      目前尝试过单元测试、接口测试、记录日志等自测手段，有了测试手段之后修改或者重构就更加安心，原来可改可不改的代码就有更足够的底气去重构了，否则有可能为了遵从良知拉着整个团队下水。
      在平台更深刻地感觉到提早发现问题的好处，一个接口及得错误一旦发布给产品，产品发布给用户，修改起来需要适配，还可能需要处理用户数据的升级，本来在发布之前发现可能需要1个小时就能够改正的错误，发现的晚甚至可能消耗一周。
```  
